
https://dfinity.org/grants/

========

- choose entry point
  linker
  ==> wasm_of_ocaml hello.bc smart_rollup_core.wasm runtime.wasm \
                 --entry kernel_run
      ==> hello.s (for debugging)
      ==> hello.wasm

=======

- target GC proposal as well
  ==> generate code

  (func $apply1 (param (ref eq) (ref eq)) (result (ref eq)) (local.get 0))

- GC: closures
  let env =  ...
  let f0 = ...
  let fn = ...
  env[0] = f0
  ....
  env[n] = fn

- optional tail recursion:
  detect the following:
    x = f(...)
    return x

- exceptions (if supported)
  ==> update Wa_structure

- partial application

- check integer overflows (integers are 31 bits only...)

- we need to keep track of ocaml int32 constants

- Partial application / over application
  apply1 really fast
  apply2 fast through indirect function
  other cases slow

- Spilling
  Naive spilling for a start?
  ==> How do we avoid spilling thousand of values?

- specialize: divide by zero / modulus / check array bound

- Rebuild call-graph
  ==> unnecessary blocks / simplification of br_table/if

- local optimizations:
  avoid store followed by unique load
  inline non-mutable expressions
  multiple cast on the same value

- issue: binaryen does not support block input parameters
  https://github.com/WebAssembly/binaryen/issues/5047

- performance of casts:
 --experimental-wasm-assume-ref-cast-succeeds
 --experimental-wasm-skip-null-checks

- directly generate wasm binary?

- GC: large constants should be generated at runtime

==============================================

GHC: https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9204/diffs
     https://gitlab.haskell.org/ghc/ghc-wasm-meta

https://depth-first.com/articles/2019/10/16/compiling-c-to-webassembly-and-running-it-without-emscripten/
clang -O3 --target=wasm32 --no-standard-libraries -Wl,--export-all -Wl,--no-entry -S foo.c

- C stubs to access the host functions
  https://reviews.llvm.org/D42520
  https://tezos.gitlab.io/alpha/smart_rollups.html#developing-wasm-kernels

- ABI
  https://github.com/WebAssembly/tool-conventions/

dart:
 https://github.com/dart-lang/sdk/blob/main/pkg/dart2wasm/lib/constants.dart

====================

BUILD PROCESS

dune exec -- js_of_ocaml ~/tezos-kernel/_build/default/src/hello.bc --pretty > hello.s
clang-16  --no-standard-libraries --target=wasm32 hello.s ../tezos-kernel/_build/default/src/smart_rollup_core/smart_rollup_core.wasm ../tezos-kernel/_build/default/src/runtime/runtime.wasm  -Wl,--no-entry -Wa,--no-type-check -o kernel.wasm

clang-16 -mexception-handling
wasm2wat --enable-exceptions  // --enable-all

====================

~/sources/binaryen/bin/wasm-opt --enable-reference-types --enable-gc

===========================

ocaml value: (ref eq)
integers: i31
string : (ref (array (mut i8)))
block : (ref (array (mut (ref eq))))
closure : (ref (struct ...))   <- patch?
===> arity f f' ...

closure
-------
  - struct: arity, unary function, full function, other fields
  - need to be patched for recursive functions
    ==> allocate each closure / build common env /
        fill pointers from closures to common env /
        store information about other functions when compiling the functions
        (perform direct calls when possible)
    constant closures ==> we can get the right closure from the env instead
  - cast when entering a function (if the env is not empty)

GC
==
https://docs.google.com/document/d/1DklC3qVuOdLHSXB5UXghM_syCh-4cMinQ50ICiXnK3Q/edit#
https://github.com/WebAssembly/binaryen/blob/main/scripts/gen-s-parser.py
https://github.com/WebAssembly/gc/blob/main/interpreter/syntax/ast.ml

Change compilation strategy for branches: push arguments to the stack

Tezos proposal:
https://docs.google.com/document/d/1QDXMuixu0cv7ukwc-JgaiwBK4SssM4eIRpzlcKpGqt0

========

