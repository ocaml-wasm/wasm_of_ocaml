
Get rid of Wa_ast.Seq?

=======

fix wa_minimize_locals (loops)
=> a variable set outside of a loop is live to the end of the loop if
   used in the loop

fix liveness (exceptions)

=======

Simple improvements
===================

- Rebuild call-graph
  ==> simplification of br_table/if

- wasm_of_ocaml specific binary: options + linking
  choose entry point
  linker
  ==> wasm_of_ocaml hello.bc smart_rollup_core.wasm runtime.wasm \
                 --entry kernel_run
      ==> hello.s (for debugging)
      ==> hello.wasm

=======

Optimization phases
===================

- local with a special type for env?
  (more generally, no longer use a generic type for locals)

- optimization pass:
  use tee to nest expressions (optimized away later on)
  mutator (call / array/struct.set) flush mutable
  other expressions can float until they are used
  flush at end of blocks

- how can we avoid some casts. see what ocaml does for floats
  shall we typecheck the program?

- local optimizations: multiple cast on the same value

=======

Remarks
=======

- issue: binaryen does not support block input parameters
  https://github.com/WebAssembly/binaryen/issues/5047

- performance of casts (v8):
 --experimental-wasm-assume-ref-cast-succeeds
 --experimental-wasm-skip-null-checks
 --experimental-wasm-skip-bounds-checks

- we have a problem with large number of variable during the
  initialization phase, which could be an issue for the GC
  ==> keep initial globals but remove entries?
  ==> run-length encoded stack maps?

==================

Possible improvements
=====================

- directly generate wasm binary?
  ==> the most stable way to use Binaryen will always be to pass it a WebAssembly binary https://github.com/WebAssembly/binaryen/issues/5591#issuecomment-1476497338
  ==> can include DWARF debug information + other custom sections
  ==> we may not need to support both a wast and an .s ouput

==============================================

DOCS

GHC: https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9204/diffs
     https://gitlab.haskell.org/ghc/ghc-wasm-meta

- C stubs to access the host functions
  https://reviews.llvm.org/D42520
  https://tezos.gitlab.io/alpha/smart_rollups.html#developing-wasm-kernels

- ABI
  https://github.com/WebAssembly/tool-conventions/

dart:
 https://github.com/dart-lang/sdk/blob/main/pkg/dart2wasm/lib/constants.dart

====================

BUILD PROCESS

dune exec -- js_of_ocaml --no-inline --pretty ~/tezos-noop-kernel/_build/default/src/hello.bc > /tmp/hello.s
clang-16  --no-standard-libraries --target=wasm32 /tmp/hello.s ../tezos-noop-kernel/_build/default/src/smart_rollup_core/smart_rollup_core.wasm ../tezos-noop-kernel/_build/default/src/runtime/runtime.wasm  -Wl,--no-entry -Wa,--no-type-check -o kernel.wasm

clang-16 -mexception-handling
wasm2wat --enable-exceptions  // --enable-all

dune exec -- js_of_ocaml --no-inline --pretty ~/tezos-noop-kernel/_build/default/src/hello.bc > /tmp/hello.wast
dune exec -- js_of_ocaml --no-inline --pretty ~/sources/tezos/_build/default/src/proto_alpha/bin_baker/main_baker_alpha.bc > /tmp/hello.wast

~/sources/binaryen/bin/wasm-opt --all-features -Oz /tmp/hello.wast -S -o -  | less
~/sources/wasm-gc-proposal/interpreter/wasm -d /tmp/hello.wast -o /tmp/hello.wat

===========================

GC proposal
===========

https://docs.google.com/document/d/1DklC3qVuOdLHSXB5UXghM_syCh-4cMinQ50ICiXnK3Q/edit#
https://github.com/WebAssembly/binaryen/blob/main/scripts/gen-s-parser.py
https://github.com/WebAssembly/gc/blob/main/interpreter/syntax/ast.ml

========

Curryfication improvements
==========================

- Each closure can hold several pointers (by copying the parent closure)
   caml_curry_n_1
- Curry function to perform a full apply when 3 arguments or less
   caml_curry_app_n_1
   caml_curry_app_n_2
   caml_curry_app_n_3
- Optimize caml_apply_n when overapplying or underapplying only a little
  Overapply:
    (f x1 ... xn') xn
    caml_apply2 (f x1 ... xn'') xn' xn
  Underapply:
    (fun x -> apply f x1 x2 ... xn x)
    (fun x y -> apply f x1 x2 ... xn x y)

    caml_apply_full_n_1
    caml_apply_full_n_2

==============================

Exception
=========

     res=f(...)
     if !res return res  (* Or jump to exception handler *)

     (No test necessary for tail calls)

     Store actual exception in a global variable

Trampoline
==========

     while(1) {
       res = f()
       if (res) return res
       if (exception pending) return res
       f = load_continuation()
     }

     if (depth < 40) f(x1, ..., xn)
     else { store (fun () -> f(x1, ..., xn)); return 0 }

     ===> create thunk functions

======================

Use one table by arity
===> function references / not supported by LLVM
===>
[wasm-gc] Optimize call_indirect type checks

Remove type check if declared signature exactly matches table
signature. Remove null check if the table is non-nullable.

=======================

We have unused globals (small constants / known closures)
===> eliminated by binaryen

===========================

Bindings:
   generate specialized JavaScript functions
      (for instance to create a literal object)
   optimize away unwrap(wrap(...))

===========================

Float unboxing: declare primitive type (or parse the runtime code to get the functions' parameter types?)

============================

Rethrow?

============================

Js_of_ocaml fixes:
==> Condition.wait should throw (never makes sense)
==> weak/ephemerons
==> Dom_html.Keyboard_code.of_event is weird

===================================

C API
=====
- https://github.com/hoodmane/libffi-emscripten
- use externref_t in clang-17
  typedef __externref_t externref_t;
  clang -c  --target=wasm32  -mreference-types

====================================================

Separate compilation (use wasm-merge for linking?)

Optimizations
- more efficient JavaScript bindings
- try to eliminate some casts / boxing
- revise bound-checking:
  => no separate checkbound (so that we can compute subexpressions only once)
  => CSE of casts / array.len
- more direct calls when we known which function is called
- objects (method calls)
- propagate more information from ocaml
  (extern statements / big array information / unsafe operation information / eqaul on int32 / ... / array length)
- use unboxed primitives for int64/int32/nativeint

============================

Doc: binding changes
- explicit coercion for floats
- cannot use ocaml physical equality to compare JavaScript values

====

wasm-opt -g only if --pretty

--traps-never-happen,-tnh ?

=====

NativeString ==> string.const

=============================

??? time_stamp_counter, bigstring_marshal_kernel,

====

export PATH=toto:/tmp/node-v21.0.0-v8-canary20230927fa59f85d60-linux-x64/bin:/home/jerome/V8/depot_tools:/home/jerome/.opam/4.14.0/bin:/home/jerome/sources/binaryen/bin:/home/jerome/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin

opam reinstall -j 8 alcotest async_js base base_bigstring bigstringaf bin_prot core core_kernel core_unix cstruct cstruct-async cstruct-lwt cstruct-sexp cstruct-unix ppx_expect ppx_inline_test string_dict time_now zarith_stubs_js

=======

Release:
- many PRs (jsoo bindings, dune, brr, gen_js_api, ...)

=====

find . -name ".*"
find . -name "*jsoo" | xargs rm
find . -name "*.wat" | xargs rm
zip -r examples.zip `find . -name "*.wasm" | cut -d '/' -f 2 | sort`

=========================

zarith 1.13

==========================

Dune
====

- compile both to js and wasm
- set node options + variable for node

====

- make it easier to debug
  ==> sourcemap / dwarf
  ==> variable names
- interface with JavaScript: improve performances
- update runtime code to new syntax
- benchmarks: effects, js_of_ocaml benchmarks
- minify JS runtime
- separate compilation / toplevel
- use unboxed primitives for int64/int32/nativeint

- improve dune support

- typed arrays

==> Wasm GC available in Chrome beta

===============

Benchmarks
==========
*   --experimental-wasm-skip-bounds-checks --experimental-wasm-skip-null-checks --experimental-wasm-assume-ref-cast-succeeds

==================

Wasm GC getting finalized. Soon available by default on Chrome.

Js_of_ocaml successful project to make OCaml program run on a browser.

Goal: compile programs to Wasm with minimal changes

==============


Wasm_of_ocaml: compiling OCaml bytecode to WasmGC

Wasm_of_ocaml: compiling OCaml bytecode to WebAssembly
Js_of_ocaml is a industrial-strength compiler that translates OCaml code into JavaScript. We will present how we are adapting it to produce WebAssembly. Beside the compilation process, we will cover a few key other points. First, how we interface with JavaScript, allowing to compile existing code with minimal changes. Second, we will show how we are relying on JavaScript to supplement some currently missing functionalities in WebAssembly. We are able to run substantial programs such as CAMLBOY, a Gameboy emulator, and the OCaml compiler itself. We will thus share some initial performance results.


how we interface with JavaScript, allowing to compile existing code with minimal changes. Second, we will show how we are relying on JavaScript to supplement some currently missing functionalities in WebAssembly

===========

Failing tests:
- /static  (not yet implemented)
- nat (need to change num)
- hash (expected)
- polymorphic comparison (more strict)
- fun_call (different type)
- json

=====

- v8::internal::compiler::Pipeline::GenerateCodeForWasmFunction
   - 93,62% v8::internal::compiler::GraphReducer::ReduceNode
      - 93,59% v8::internal::compiler::GraphReducer::ReduceTop
         - 93,38% v8::internal::compiler::GraphReducer::Reduce
            - 54,93% v8::internal::compiler::CsaLoadElimination::ReduceEffectPhi
               + 54,91% v8::internal::compiler::CsaLoadElimination::HalfState::IntersectWith<unsigned int>
            - 28,42% v8::internal::compiler::WasmLoadElimination::ReduceEffectPhi
               + 28,41% v8::internal::compiler::WasmLoadElimination::HalfState::IntersectWith
            + 9,43% v8::internal::compiler::WasmLoadElimination::UpdateState
   + 3,35% v8::internal::compiler::PipelineImpl::SelectInstructions
   + 1,47% v8::internal::compiler::PipelineImpl::ComputeScheduledGraph

================

    New eliom compilation process
22dbf307f153599e5f860771fe49bb3aa108dbc9
    [dune] Recompile on database change
b589c8bf5da7179da971c0637eaa88a825b0e5bf
    Switch to dune
31ccf51c5bffabcb7bdf03e9e567c6af82e3d961

=============

- dead code elimination
- effects PR
- blog post
- PR Garrigue

=============================

Release plans
=============
- Make it possible to release libraries
  - dune support
  - js_of_ocaml release
- Merge with Js_of_ocaml
  - rebase

==============

Issue on
https://github.com/WebAssembly/js-string-builtins/blob/main/proposals/js-string-builtins/Overview.md

Understand type arrays: specific primitive?
==> caml_js_ta_get/set

Pass more tests?
   grep -lR  @tags".*"js . | xargs -n 1 dirname | sort | uniq
Deploy tests

How can we avoid some JavaScript wrapping / unwrapping?

caml_js_object
eval

=======================================


Handle<Map> CreateArrayMap(Isolate* isolate) {
  const wasm::ArrayType* type = new ArrayType (kWasmI8, true);
  const int inobject_properties = 0;
  const int instance_size = kVariableSizeSentinel;
  // Wasm Arrays don't have a static instance size.
  const int cached_instance_size = 0;
  const InstanceType instance_type = WASM_ARRAY_TYPE;
  const ElementsKind elements_kind = TERMINAL_FAST_ELEMENTS_KIND;
  Handle<WasmTypeInfo> type_info = isolate->factory()->NewWasmTypeInfo(
      reinterpret_cast<Address>(type), NULL, cached_instance_size,
      NULL, 0);
  Handle<Map> map = isolate->factory()->NewMap(
      instance_type, instance_size, elements_kind, inobject_properties);
  map->set_wasm_type_info(*type_info);
  map->SetInstanceDescriptors(isolate,
                              *isolate->factory()->empty_descriptor_array(), 0);
  map->set_is_extensible(false);
  WasmArray::EncodeElementSizeInMap(type->element_type().value_kind_size(),
                                    *map);
  return map;
}

See also WasmJSFunction::New in wasm/wasm-objects.cc
