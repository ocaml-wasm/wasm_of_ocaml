ZZZ OKRA ZZZ

=====

- choose entry point
  linker
  ==> wasm_of_ocaml hello.bc smart_rollup_core.wasm runtime.wasm \
                 --entry kernel_run
      ==> hello.s (for debugging)
      ==> hello.wasm

=======

- partial application

- target GC proposal as well

- check integer overflows (integers are 31 bits only...)

- Constants
  ==> statically allocated ==> int32/int64/floats

- we need to keep track of int32 constants

- Partial application / over application
  apply1 really fast
  apply2 fast through indirect function
  other cases slow

- Spilling
  Naive spilling for a start?
  ==> How do we avoid spilling thousand of values?

- specialize: divide by zero / modulus / check array bound

- Rebuild call-graph
  ==> check for unnecessary blocks, branches, returns

- local optimizations: constants used only once can be moved;
  avoid store followed by unique load
  ...

==============================================

GHC: https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9204/diffs
     https://gitlab.haskell.org/ghc/ghc-wasm-meta

https://depth-first.com/articles/2019/10/16/compiling-c-to-webassembly-and-running-it-without-emscripten/
clang -O3 --target=wasm32 --no-standard-libraries -Wl,--export-all -Wl,--no-entry -S foo.c

- C stubs to access the host functions
  https://reviews.llvm.org/D42520
  https://tezos.gitlab.io/alpha/smart_rollups.html#developing-wasm-kernels

====================

BUILD PROCESS

dune exec -- js_of_ocaml ~/tezos-kernel/_build/default/src/hello.bc --pretty > hello.s
clang-16  --no-standard-libraries --target=wasm32 hello.s ../tezos-kernel/_build/default/src/smart_rollup_core/smart_rollup_core.wasm ../tezos-kernel/_build/default/src/runtime/runtime.wasm  -Wl,--no-entry -o kernel.wasm
