
Get rid of Wa_ast.Seq?

=======

fix wa_minimize_locals (loops)
=> a variable set outside of a loop is live to the end of the loop if
   used in the loop

fix liveness (exceptions)

=======

Simple improvements
===================

- Rebuild call-graph
  ==> simplification of br_table/if

- wasm_of_ocaml specific binary: options + linking
  choose entry point
  linker
  ==> wasm_of_ocaml hello.bc smart_rollup_core.wasm runtime.wasm \
                 --entry kernel_run
      ==> hello.s (for debugging)
      ==> hello.wasm

=======

Optimization phases
===================

- local with a special type for env?
  (more generally, no longer use a generic type for locals)

- optimization pass:
  use tee to nest expressions (optimized away later on)
  mutator (call / array/struct.set) flush mutable
  other expressions can float until they are used
  flush at end of blocks

- how can we avoid some casts. see what ocaml does for floats
  shall we typecheck the program?

- local optimizations: multiple cast on the same value

=======

Remarks
=======

- issue: binaryen does not support block input parameters
  https://github.com/WebAssembly/binaryen/issues/5047

- performance of casts (v8):
 --experimental-wasm-assume-ref-cast-succeeds
 --experimental-wasm-skip-null-checks
 --experimental-wasm-skip-bounds-checks

- we have a problem with large number of variable during the
  initialization phase, which could be an issue for the GC
  ==> keep initial globals but remove entries?
  ==> run-length encoded stack maps?

==================

Possible improvements
=====================

- directly generate wasm binary?
  ==> the most stable way to use Binaryen will always be to pass it a WebAssembly binary https://github.com/WebAssembly/binaryen/issues/5591#issuecomment-1476497338
  ==> can include DWARF debug information + other custom sections
  ==> we may not need to support both a wast and an .s ouput

==============================================

DOCS

GHC: https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9204/diffs
     https://gitlab.haskell.org/ghc/ghc-wasm-meta

- C stubs to access the host functions
  https://reviews.llvm.org/D42520
  https://tezos.gitlab.io/alpha/smart_rollups.html#developing-wasm-kernels

- ABI
  https://github.com/WebAssembly/tool-conventions/

dart:
 https://github.com/dart-lang/sdk/blob/main/pkg/dart2wasm/lib/constants.dart

====================

BUILD PROCESS

dune exec -- js_of_ocaml --no-inline --pretty ~/tezos-noop-kernel/_build/default/src/hello.bc > /tmp/hello.s
clang-16  --no-standard-libraries --target=wasm32 /tmp/hello.s ../tezos-noop-kernel/_build/default/src/smart_rollup_core/smart_rollup_core.wasm ../tezos-noop-kernel/_build/default/src/runtime/runtime.wasm  -Wl,--no-entry -Wa,--no-type-check -o kernel.wasm

clang-16 -mexception-handling
wasm2wat --enable-exceptions  // --enable-all

dune exec -- js_of_ocaml --no-inline --pretty ~/tezos-noop-kernel/_build/default/src/hello.bc > /tmp/hello.wast
dune exec -- js_of_ocaml --no-inline --pretty ~/sources/tezos/_build/default/src/proto_alpha/bin_baker/main_baker_alpha.bc > /tmp/hello.wast

~/sources/binaryen/bin/wasm-opt --all-features -Oz /tmp/hello.wast -S -o -  | less
~/sources/wasm-gc-proposal/interpreter/wasm -d /tmp/hello.wast -o /tmp/hello.wat

===========================

GC proposal
===========

https://docs.google.com/document/d/1DklC3qVuOdLHSXB5UXghM_syCh-4cMinQ50ICiXnK3Q/edit#
https://github.com/WebAssembly/binaryen/blob/main/scripts/gen-s-parser.py
https://github.com/WebAssembly/gc/blob/main/interpreter/syntax/ast.ml

========

Curryfication improvements
==========================

- Each closure can hold several pointers (by copying the parent closure)
   caml_curry_n_1
- Curry function to perform a full apply when 3 arguments or less
   caml_curry_app_n_1
   caml_curry_app_n_2
   caml_curry_app_n_3
- Optimize caml_apply_n when overapplying or underapplying only a little
  Overapply:
    (f x1 ... xn') xn
    caml_apply2 (f x1 ... xn'') xn' xn
  Underapply:
    (fun x -> apply f x1 x2 ... xn x)
    (fun x y -> apply f x1 x2 ... xn x y)

    caml_apply_full_n_1
    caml_apply_full_n_2

==============================

Exception
=========

     res=f(...)
     if !res return res  (* Or jump to exception handler *)

     (No test necessary for tail calls)

     Store actual exception in a global variable

Trampoline
==========

     while(1) {
       res = f()
       if (res) return res
       if (exception pending) return res
       f = load_continuation()
     }

     if (depth < 40) f(x1, ..., xn)
     else { store (fun () -> f(x1, ..., xn)); return 0 }

     ===> create thunk functions

======================

Use one table by arity
===> function references / not supported by LLVM
===>
[wasm-gc] Optimize call_indirect type checks

Remove type check if declared signature exactly matches table
signature. Remove null check if the table is non-nullable.

=======================

We have unused globals (small constants / known closures)
===> eliminated by binaryen

===========================

Bindings:
   generate specialized JavaScript functions
      (for instance to create a literal object)
   optimize away unwrap(wrap(...))

===========================

Float unboxing: declare primitive type (or parse the runtime code to get the functions' parameter types?)

============================

Rethrow?

============================

Js_of_ocaml fixes:
==> Condition.wait should throw (never makes sense)
==> weak/ephemerons
==> Dom_html.Keyboard_code.of_event is weird

===================================

C API
=====
- https://github.com/hoodmane/libffi-emscripten
- use externref_t in clang-17
  typedef __externref_t externref_t;
  clang -c  --target=wasm32  -mreference-types

====================================================

Separate compilation (use wasm-merge for linking?)

Optimizations
- more efficient JavaScript bindings
- unboxed float arrays
- try to eliminate some casts / boxing
- more direct calls when we known which function is called
- objects (method calls)
- propagate more information from ocaml
  (extern statements / big array information / unsafe operation information)
- use unboxed primitives for int64/int32/nativeint

============================

Doc: binding changes
- explicit coercion for floats
- cannot use ocaml physical equality to compare JavaScript values

====

wasm-opt -g only if --pretty

--traps-never-happen,-tnh ?

=====

NativeString ==> string.const

=============================

??? time_stamp_counter, bigstring_marshal_kernel,

====

export PATH=toto:/tmp/node-v21.0.0-v8-canary202307207f6d94de9e-linux-x64/bin:/home/jerome/V8/depot_tools:/home/jerome/.opam/4.14.0/bin:/home/jerome/sources/binaryen/bin:/home/jerome/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin
export PATH=toto:/tmp/node-v21.0.0-v8-canary20230906bca67b72ce-linux-x64/bin:/home/jerome/V8/depot_tools:/home/jerome/.opam/4.14.0/bin:/home/jerome/sources/binaryen/bin:/home/jerome/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin

=======

Release:
- many PRs (jsoo bindings, dune, brr, gen_js_api, ...)

=====

find . -name ".*"
find . -name "*jsoo" | xargs rm
find . -name "*.wat" | xargs rm
zip -r examples.zip `find . -name "*.wasm" | cut -d '/' -f 2 | sort`

=========================

zarith 1.13

==========================

Dune
====

- compile both to js and wasm
- set node options + variable for node

====

ZZZ bin_prot: floatarray

- update runtime code to new syntax
- improve dune support
- catch file system errors
- benchmarks: effects, js_of_ocaml benchmarks
- marshaling: use JavaScript maps
- wasm-opt options depending on --opt
- unbox float arrays
- minify JS runtime
- eliom
- separate compilation / toplevel
- use unboxed primitives for int64/int32/nativeint
