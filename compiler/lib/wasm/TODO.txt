
Get rid of Wa_ast.Seq?

=======

fix wa_minimize_locals (loops)
=> a variable set outside of a loop is live to the end of the loop if
   used in the loop

fix liveness (exceptions)

=======

Simple improvements
===================

- Rebuild call-graph
  ==> simplification of br_table/if

- wasm_of_ocaml specific binary: options + linking
  choose entry point
  linker
  ==> wasm_of_ocaml hello.bc smart_rollup_core.wasm runtime.wasm \
                 --entry kernel_run
      ==> hello.s (for debugging)
      ==> hello.wasm

=======

Optimization phases
===================

- local with a special type for env?
  (more generally, no longer use a generic type for locals)

- optimization pass:
  use tee to nest expressions (optimized away later on)
  mutator (call / array/struct.set) flush mutable
  other expressions can float until they are used
  flush at end of blocks

- how can we avoid some casts. see what ocaml does for floats
  shall we typecheck the program?

- local optimizations: multiple cast on the same value

=======

Remarks
=======

- issue: binaryen does not support block input parameters
  https://github.com/WebAssembly/binaryen/issues/5047

- performance of casts (v8):
 --experimental-wasm-assume-ref-cast-succeeds
 --experimental-wasm-skip-null-checks
 --experimental-wasm-skip-bounds-checks

- we have a problem with large number of variable during the
  initialization phase, which could be an issue for the GC
  ==> keep initial globals but remove entries?
  ==> run-length encoded stack maps?

==================

Possible improvements
=====================

- directly generate wasm binary?
  ==> the most stable way to use Binaryen will always be to pass it a WebAssembly binary https://github.com/WebAssembly/binaryen/issues/5591#issuecomment-1476497338
  ==> can include DWARF debug information + other custom sections
  ==> we may not need to support both a wast and an .s ouput

==============================================

DOCS

GHC: https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9204/diffs
     https://gitlab.haskell.org/ghc/ghc-wasm-meta

- C stubs to access the host functions
  https://reviews.llvm.org/D42520
  https://tezos.gitlab.io/alpha/smart_rollups.html#developing-wasm-kernels

- ABI
  https://github.com/WebAssembly/tool-conventions/

dart:
 https://github.com/dart-lang/sdk/blob/main/pkg/dart2wasm/lib/constants.dart

====================

BUILD PROCESS

dune exec -- js_of_ocaml --no-inline --pretty ~/tezos-noop-kernel/_build/default/src/hello.bc > /tmp/hello.s
clang-16  --no-standard-libraries --target=wasm32 /tmp/hello.s ../tezos-noop-kernel/_build/default/src/smart_rollup_core/smart_rollup_core.wasm ../tezos-noop-kernel/_build/default/src/runtime/runtime.wasm  -Wl,--no-entry -Wa,--no-type-check -o kernel.wasm

clang-16 -mexception-handling
wasm2wat --enable-exceptions  // --enable-all

dune exec -- js_of_ocaml --no-inline --pretty ~/tezos-noop-kernel/_build/default/src/hello.bc > /tmp/hello.wast
dune exec -- js_of_ocaml --no-inline --pretty ~/sources/tezos/_build/default/src/proto_alpha/bin_baker/main_baker_alpha.bc > /tmp/hello.wast

~/sources/binaryen/bin/wasm-opt --all-features -Oz /tmp/hello.wast -S -o -  | less
~/sources/wasm-gc-proposal/interpreter/wasm -d /tmp/hello.wast -o /tmp/hello.wat

===========================

GC proposal
===========

https://docs.google.com/document/d/1DklC3qVuOdLHSXB5UXghM_syCh-4cMinQ50ICiXnK3Q/edit#
https://github.com/WebAssembly/binaryen/blob/main/scripts/gen-s-parser.py
https://github.com/WebAssembly/gc/blob/main/interpreter/syntax/ast.ml

========

Curryfication improvements
==========================

- Each closure can hold several pointers (by copying the parent closure)
   caml_curry_n_1
- Curry function to perform a full apply when 3 arguments or less
   caml_curry_app_n_1
   caml_curry_app_n_2
   caml_curry_app_n_3
- Optimize caml_apply_n when overapplying or underapplying only a little
  Overapply:
    (f x1 ... xn') xn
    caml_apply2 (f x1 ... xn'') xn' xn
  Underapply:
    (fun x -> apply f x1 x2 ... xn x)
    (fun x y -> apply f x1 x2 ... xn x y)

    caml_apply_full_n_1
    caml_apply_full_n_2

==============================

Exception
=========

     res=f(...)
     if !res return res  (* Or jump to exception handler *)

     (No test necessary for tail calls)

     Store actual exception in a global variable

Trampoline
==========

     while(1) {
       res = f()
       if (res) return res
       if (exception pending) return res
       f = load_continuation()
     }

     if (depth < 40) f(x1, ..., xn)
     else { store (fun () -> f(x1, ..., xn)); return 0 }

     ===> create thunk functions

======================

Use one table by arity
===> function references / not supported by LLVM
===>
[wasm-gc] Optimize call_indirect type checks

Remove type check if declared signature exactly matches table
signature. Remove null check if the table is non-nullable.

=======================

Final types can be used for struct/array casts as well
==>
[wasm-gc] Final types

We add final types to wasm-gc.
- We introduce a `kWasmSubtypeFinalCode` as an alternative to
  `kWasmSubtypeCode`.
- Behind a flag, we interpret types behind this code as final, as well
  as types outside a subtype definition by default.
- For final types, type checks for call_indirect and ref.test etc. are
  reduced to simple type identity checks.

====================

We have unused globals (small constants / known closures)
===> eliminated by binaryen

===========================

Bindings:
   generate specialized JavaScript functions
      (for instance to create a literal object)
   optimize away unwrap(wrap(...))

===========================

Float unboxing: declare primitive type (or parse the runtime code to get the functions' parameter types?)

============================

Use WASI for system functions

NativeString ==> stringref const

============================

Rethrow?

============================

Js_of_ocaml fixes:
==> bound check optimization for float arrays
==> strict equality
==> Condition.wait should throw (never makes sense)

===============================

Performance improvements:
- Refine exact calls: when there is a single function called, then we
  can call it directly.
- float arrays
- use unboxed primitives for int64/int32/nativeint

===================================

C API
=====
- https://github.com/hoodmane/libffi-emscripten
- use externref_t in clang-17
  typedef __externref_t externref_t;
  clang -c  --target=wasm32  -mreference-types

====================================================

Compilation process
===================

wasm_of_ocaml foo.bc ==> foo.js / foo.wasm
   - compile to a temp file (.wat file with -S option)
minify js runtime

===

TODO:

Implement runtime code
- file system access
- marshalling
- weak pointer api
  ==> Use Javascript weak pointer implementation
...

Separate compilation (use wasm-merge for linking?)

Optimizations
- more efficient JavaScript bindings
- unboxed float arrays
- try to eliminate some casts / boxing
- more direct calls when we known which function is called
- objects (method calls)
- propagate more information from ocaml
  (extern statements / big array information / unsafe operation information)

=================

Remaining runtime code:
- printing errors (needs basic implementation of stderr on browsers)
- weak / ephemeron
- marshaling
- filesystem / IOs
- dynlink / toplevel / separate compilation
- jslib_js_of_ocaml

Less important:
- graphics
- nat

Files:
  dynlink
  fs
  graphics
  io
  jslib_js_of_ocaml
  marshal
  md5 (not channel)
  nat
  runtime_events
  stdlib
  sys
  toplevel
  unix (gettimeofday / time / gmtime)
  weak

- node bindings (I/Os)
- virtual filesystem
- toplevel

=========================

TODO

- dune support
  ==> link (wasm_runtime) wat/wast/wasm files  (jsoo_runtime)
  ==> wasm_files (javascript_files)
  ==> node options ===> (node_flags ...)

- we should link-in javascript files that are not divided into fragments

- documentation
  ==> what tools (node/chrome/binaryen/dune) are needed/supported
  ==> how do we run wasm_of_ocaml
      output: foo.js / foo.wasm / foo.wat
      wasm-opt -all -S -o - foo.wasm

=================================

Linker:
annotate provides to indicate that they should be available in Wasm

============================

Doc: binding changes
- explicit coercion for floats
- cannot use ocaml physical equality to compare JavaScript values

====

wasm-opt -g only if --pretty

--traps-never-happen,-tnh ?

=====

NativeString ==> string.const

=============================

marshaling: use JavaScript maps

================


* bin_prot/src/runtime.js
* zarith_stubs_js/src/runtime.js

??? time_stamp_counter, bigstring_marshal_kernel,

====================

How to compile
- wasm_of_ocaml --pretty  --opt 3 ~/CAMLBOY/_build/default/bin/web/bench.bc-for-jsoo

TODO:
- dune support

fix caml_js_on_ie

==============

Changes to JavaScript bindings

I have been thinking about generating WebAssembly code. To improve compatibility, I propose the following changes:
- The OCaml comparison functions no longer coincide with JavaScript comparisons functions, so we should provide explicit bindings for this functions.
- OCaml floats will no longer be implemented as JavaScript numbers, so explicit conversion functions should be available (and no longer deprecated).

====

README:
- changes compared to js_of_ocaml
- less options (no separate compilation for now)
- status

Basic output in browsers (stdout / stderr going to the console)

Typed arrays

Performance (too many locals)

=============

LWT / PR raphael proust

=============

read at current fd offset
seek: adjusts the fd offset
(after a seek, read from current offset)

===

zarith:
ml_z_of_substring_base
ml_z_init
ml_z_format

=========================

export PATH=toto:/tmp/node-v21.0.0-v8-canary202307207f6d94de9e-linux-x64/bin:/home/jerome/V8/depot_tools:/home/jerome/.opam/4.14.0/bin:/home/jerome/sources/binaryen/bin:/home/jerome/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin

cd ~/sources/bonsai/_build/default/web_ui/not_connected_warning_box/test

perf record node --experimental-wasm-stringref --experimental-wasm-gc --experimental-wasm-stack-switching .bonsai_web_ui_not_connected_warning_box_test.inline-tests/inline_test_runner_bonsai_web_ui_not_connected_warning_box_test.bc.js inline-test-runner bonsai_web_ui_not_connected_warning_box_test -source-tree-root ../../.. -diff-cmd -

cd ~/sources/bonsai/_build/default/web_ui/not_connected_warning_box/test/.bonsai_web_ui_not_connected_warning_box_test.inline-tests
wasm-opt  -O2 -all -o toto.wasm before.wasm
