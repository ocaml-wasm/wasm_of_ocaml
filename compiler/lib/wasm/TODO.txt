
- C stubs to access the host functions
  https://reviews.llvm.org/D42520
  https://tezos.gitlab.io/alpha/smart_rollups.html#developing-wasm-kernels

- Closure conversion
  ==> allocate closures

- Constants
  ==> statically allocated
  ==> closures with no free variable as well

- Rebuild call-graph
  ==> check for unnecessary blocks and branches

- Spilling
  Naive spilling for a start?

- Partial application / over application
  apply1 really fast
  apply2 fast through indirect function
  other cases slow

- Global variables: defined at toplevel and used in functions
  (or only use locals?)

- Linear allocator:
  => Scan code; live from first local.set (not included) to last local.get.
  => Sort variables by first occurence
  => iter over code
     leaving an interval ==> release variable
     entering an interval ==> acquire a variable
     hint: same variable in case of assignment?

            .section .data.const,"",@
            .p2align 2
    const1:
            .size const1, 12
            .int32 2816
            .int32 7
            .int32 const0+4
    const0:
            .size const0, 12
            .int32 2816
            .int32 9
            .int32 1
            .set foo,const0+4
    str:
            .size str, 4
            .ascii "0\x42\x43\x44"


GHC: https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9204/diffs

==============================================

https://depth-first.com/articles/2019/10/16/compiling-c-to-webassembly-and-running-it-without-emscripten/
clang -O3 --target=wasm32 --no-standard-libraries -Wl,--export-all -Wl,--no-entry -S foo.c


        .text
        .file   "foo.c"
        .tabletype      __indirect_function_table, funcref
        .functype       f (i32) -> (i32)
        .functype       h (i32) -> (i32)
        .functype       k () -> (i32)
        .section        .text.f,"",@
        .hidden f                               # -- Begin function f
        .globl  f
        .type   f,@function
f:                                      # @f
        .functype       f (i32) -> (i32)
# %bb.0:
        local.get       0
        i32.const       1
        i32.shl 
                                        # fallthrough-return
        end_function
.Lfunc_end0:
        .size   f, .Lfunc_end0-f
                                        # -- End function
        .section        .text.h,"",@
        .hidden h                               # -- Begin function h
        .globl  h
        .type   h,@function
h:                                      # @h
        .functype       h (i32) -> (i32)
# %bb.0:
        local.get       0
        call_indirect    () -> (i32)
                                        # fallthrough-return
        end_function
.Lfunc_end1:
        .size   h, .Lfunc_end1-h
                                        # -- End function
        .section        .text.k,"",@
        .hidden k                               # -- Begin function k
        .globl  k
        .type   k,@function
k:                                      # @k
        .functype       k () -> (i32)
# %bb.0:
        i32.const       0
                                        # fallthrough-return
        end_function
.Lfunc_end2:
