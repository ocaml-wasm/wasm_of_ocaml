
Get rid of Wa_ast.Seq?

=======

fix wa_minimize_locals (loops)
=> a variable set outside of a loop is live to the end of the loop if
   used in the loop

fix liveness (exceptions)

=======

Simple improvements
===================

- Rebuild call-graph
  ==> simplification of br_table/if

- wasm_of_ocaml specific binary: options + linking
  choose entry point
  linker
  ==> wasm_of_ocaml hello.bc smart_rollup_core.wasm runtime.wasm \
                 --entry kernel_run
      ==> hello.s (for debugging)
      ==> hello.wasm

=======

Optimization phases
===================

- local with a special type for env?
  (more generally, no longer use a generic type for locals)

- optimization pass:
  use tee to nest expressions (optimized away later on)
  mutator (call / array/struct.set) flush mutable
  other expressions can float until they are used
  flush at end of blocks

- how can we avoid some casts. see what ocaml does for floats
  shall we typecheck the program?

- local optimizations: multiple cast on the same value

=======

Remarks
=======

- issue: binaryen does not support block input parameters
  https://github.com/WebAssembly/binaryen/issues/5047

- performance of casts (v8):
 --experimental-wasm-assume-ref-cast-succeeds
 --experimental-wasm-skip-null-checks
 --experimental-wasm-skip-bounds-checks

- we have a problem with large number of variable during the
  initialization phase, which could be an issue for the GC
  ==> keep initial globals but remove entries?
  ==> run-length encoded stack maps?

==================

Possible improvements
=====================

- directly generate wasm binary?
  ==> the most stable way to use Binaryen will always be to pass it a WebAssembly binary https://github.com/WebAssembly/binaryen/issues/5591#issuecomment-1476497338
  ==> can include DWARF debug information + other custom sections
  ==> we may not need to support both a wast and an .s ouput

==============================================

DOCS

GHC: https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9204/diffs
     https://gitlab.haskell.org/ghc/ghc-wasm-meta

- C stubs to access the host functions
  https://reviews.llvm.org/D42520
  https://tezos.gitlab.io/alpha/smart_rollups.html#developing-wasm-kernels

- ABI
  https://github.com/WebAssembly/tool-conventions/

dart:
 https://github.com/dart-lang/sdk/blob/main/pkg/dart2wasm/lib/constants.dart

====================

BUILD PROCESS

dune exec -- js_of_ocaml --no-inline --pretty ~/tezos-noop-kernel/_build/default/src/hello.bc > /tmp/hello.s
clang-16  --no-standard-libraries --target=wasm32 /tmp/hello.s ../tezos-noop-kernel/_build/default/src/smart_rollup_core/smart_rollup_core.wasm ../tezos-noop-kernel/_build/default/src/runtime/runtime.wasm  -Wl,--no-entry -Wa,--no-type-check -o kernel.wasm

clang-16 -mexception-handling
wasm2wat --enable-exceptions  // --enable-all

dune exec -- js_of_ocaml --no-inline --pretty ~/tezos-noop-kernel/_build/default/src/hello.bc > /tmp/hello.wast
dune exec -- js_of_ocaml --no-inline --pretty ~/sources/tezos/_build/default/src/proto_alpha/bin_baker/main_baker_alpha.bc > /tmp/hello.wast

~/sources/binaryen/bin/wasm-opt --all-features -Oz /tmp/hello.wast -S -o -  | less
~/sources/wasm-gc-proposal/interpreter/wasm -d /tmp/hello.wast -o /tmp/hello.wat

===========================

GC proposal
===========

https://docs.google.com/document/d/1DklC3qVuOdLHSXB5UXghM_syCh-4cMinQ50ICiXnK3Q/edit#
https://github.com/WebAssembly/binaryen/blob/main/scripts/gen-s-parser.py
https://github.com/WebAssembly/gc/blob/main/interpreter/syntax/ast.ml

========

Curryfication improvements
==========================

- Each closure can hold several pointers (by copying the parent closure)
   caml_curry_n_1
- Curry function to perform a full apply when 3 arguments or less
   caml_curry_app_n_1
   caml_curry_app_n_2
   caml_curry_app_n_3
- Optimize caml_apply_n when overapplying or underapplying only a little
  Overapply:
    (f x1 ... xn') xn
    caml_apply2 (f x1 ... xn'') xn' xn
  Underapply:
    (fun x -> apply f x1 x2 ... xn x)
    (fun x y -> apply f x1 x2 ... xn x y)

    caml_apply_full_n_1
    caml_apply_full_n_2

==============================

Use one table by arity
===> function references / not supported by LLVM
===>
[wasm-gc] Optimize call_indirect type checks

Remove type check if declared signature exactly matches table
signature. Remove null check if the table is non-nullable.

=======================

We have unused globals (small constants / known closures)
===> eliminated by binaryen

===========================

Float unboxing: declare primitive type (or parse the runtime code to get the functions' parameter types?)

============================

Rethrow?

============================

Js_of_ocaml fixes:
==> Condition.wait should throw (never makes sense)
==> weak/ephemerons
==> Dom_html.Keyboard_code.of_event is weird
==> change equality semantics?

===================================

C API
=====
- https://github.com/hoodmane/libffi-emscripten
- use externref_t in clang-17
  typedef __externref_t externref_t;
  clang -c  --target=wasm32  -mreference-types

====================================================

Separate compilation (use wasm-merge for linking?)

Optimizations
- more efficient JavaScript bindings
- try to eliminate some casts / boxing
- revise bound-checking:
  => no separate checkbound (so that we can compute subexpressions only once)
  => CSE of casts / array.len
- more direct calls when we known which function is called
- objects (method calls)
- propagate more information from ocaml
  (extern statements / big array information / unsafe operation information / eqaul on int32 / ... / array length)
- use unboxed primitives for int64/int32/nativeint

============================

Doc: binding changes
- explicit coercion for floats
- cannot use ocaml physical equality to compare JavaScript values

====

wasm-opt -g only if --pretty

--traps-never-happen,-tnh ?

=====

NativeString ==> string.const

=============================

??? time_stamp_counter, bigstring_marshal_kernel,

====

export PATH=toto:/tmp/node-v22.0.0-v8-canary20231204cf8ac0f493-linux-x64/bin:/home/jerome/V8/depot_tools:/home/jerome/.opam/4.14.0/bin:/home/jerome/sources/binaryen/bin:/home/jerome/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin

opam reinstall -j 8 alcotest async_js base base_bigstring bigstringaf bin_prot core core_kernel core_unix cstruct cstruct-async cstruct-lwt cstruct-sexp cstruct-unix ppx_expect ppx_inline_test string_dict time_now zarith_stubs_js

=======

Release:
- many PRs (jsoo bindings, dune, brr, gen_js_api, ...)

=====

find . -name ".*"
find . -name "*jsoo" | xargs rm
find . -name "*.wat" | xargs rm
zip -r examples.zip `find . -name "*.wasm" | cut -d '/' -f 2 | sort`

=========================

zarith 1.13

==========================

Dune
====

- compile both to js and wasm
- set node options + variable for node

====

- make it easier to debug
  ==> sourcemap / dwarf
  ==> variable names
- interface with JavaScript: improve performances
- update runtime code to new syntax
- benchmarks: effects, js_of_ocaml benchmarks
- minify JS runtime
- toplevel
- use unboxed primitives for int64/int32/nativeint

- improve dune support

- typed arrays

===============

Benchmarks
==========
*   --experimental-wasm-skip-bounds-checks --experimental-wasm-skip-null-checks --experimental-wasm-assume-ref-cast-succeeds

==================

Failing tests:
- /static  (not yet implemented)
- nat (need to change num)
- hash (expected)
- polymorphic comparison (more strict)
- fun_call (different type)
- json

================

- dead code elimination
- effects PR
- blog post
- PR Garrigue

=============================

Release plans
=============
- Make it possible to release libraries
  - dune support
  - js_of_ocaml release
- Merge with Js_of_ocaml
  - rebase

==============

Issue on
https://github.com/WebAssembly/js-string-builtins/blob/main/proposals/js-string-builtins/Overview.md

Understand type arrays: specific primitive?
==> caml_js_ta_get/set

Pass more tests?
   grep -lR  @tags".*"js . | xargs -n 1 dirname | sort | uniq
Deploy tests

How can we avoid some JavaScript wrapping / unwrapping?

eval
caml_js_delete

====


real	0m22,126s
real	0m21,890s

~86%
GGG
real	0m16,482s

==> 25%


real	0m12,482s

real	0m6,4     (cache)

real    0m5.526s  (sampling)

real	0m5,085s  (is_catchable_by_wasm)

real    0m3.95s  (remove frame iterator)

===> optimize FrameFinder


out/x64.release/d8 --test test/mjsunit/mjsunit.js test/mjsunit/wasm/externref.js --random-seed=-167637331 --nohard-abort --testing-d8-test-runner --expose-wasm --expose-gc --allow-natives-syntax

==================

real	0m4,458s
real	0m3.95s

real	0m14,776s
real	0m12,852s

https://chromium-review.googlesource.com/c/v8/v8/+/2113375/3..5/src/execution/isolate-inl.h#b89

----

before: 87% ==> 19s
after: 62%  ==> 2.4s


(6.884+6.571+6.660+6.572+6.649+6.549)/6
==> 6.65

(5.570+5.512+5.469+5.531+5.642+5.557)/6
==> 5.55


#ifdef DEBUG
  intptr_t marker =
      Memory<intptr_t>(fp() + CommonFrameConstants::kContextOrFrameTypeOffset);
  DCHECK(StackFrame::MarkerToType(marker) == WASM);
#endif

effect olivier
internship?

================

for i in *; do (echo ZZZ $i; cd $i; git diff); done |& less

================================

Cost of casts for bonsai test
Bonsai / CPS

===================

- compile =>
  - get_global/set_global
    ==> always blocks, to avoid one cast?

===================================


models/bindings/DebuggerLanguagePlugins.ts
==> await this.#plugin.evaluate

models/extensions/ExtensionServer.ts
==>  await this.loadWasmValue<Chrome.DevTools.WasmValue>(`globals[${global}]`, message.stopId);

export class RemoteObjectImpl extends RemoteObject {
  ==> doGetProperties
export class ScopeRemoteObject extends RemoteObjectImpl {

class SourceScopeRemoteObject extends SDK.RemoteObject.RemoteObjectImpl {

Protocol.Runtime.RemoteObject??

If the object is opaque, we query the object id when calling
Debugger.evaluateOnCallFrame (and return it)
==> and return the id to SourceScopeRemoteObject

ExtensionRemoteObject
  ==> call this.plugin.getProperties    plugin:DebuggerLanguagePlugin

https://chromium.googlesource.com/devtools/devtools-frontend/+/HEAD/docs/get_the_code.md
https://docs.google.com/document/d/1WNF-KqRSzPLUUfZqQG5AFeU_Ll8TfWYcJasa_XGf7ro/view
https://developer.chrome.com/docs/extensions/get-started/tutorial/debug?hl=fr
https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-evaluateOnCallFrame
https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-RemoteObject
preview
    {"result":
{"type":"object","subtype":"wasmvalue","className":"Object","description":"i32","objectId":"6023553991337610027.11.9",
 "preview":{"type":"object","subtype":"wasmvalue","description":>"i32"<,"overflow":false,"properties":[{"name":"value","type":"number","value":>"66560"<}]}}}
json:
   {"type":"i32", "value": 66560}   (type number)

{type: o.description, value: Number(o.preview.properties.find((o)=>o.name=="value").value)};

{"type": "ref", "value": any /*Runtime.RemoteObject*/}


1. DevTools:
   from loadWasmValue, add a value {type:"other", value: "RemoteObject"}
2. Extension: serialize values of type other
3. Extension: CustomFormatters.asRemoteObject:
   return value of type other, value RemoteObject
4. In models/bindings/DebuggerLanguagePlugins.ts, build a Remote object from
   this value
   ==> see doGetProperties ==> this.createRemoteObject(property.value)
    RuntimeModel.createRemoteObject
callFrame.debuggerModel.runtimeModel()

=========================

check test_poly_compare.ml

======

zarith: we can share some code with the javascript bindings using a flag

integer roots:
https://github.com/waldemarhorwat/integer-roots/tree/main

=============

unwrap (struct.new $js x) ==> x
unwrap (wrap x) ==> x  only if x is not 'struct.new $js y'

====> use struct.new $js x when we know x should be wrapped
      (is a string, for instance)

=========

sourcemap ==> need option -I to find files?

===

TO ASK
------
- which test was disabled?
      match Sys.backend with Other "js_of_ocaml" -> ...
- which option beside -I would be needed?

=============

TODO:
- separate compilation
  ==> check we have a single runtime file at the beginning
  ==> use better name(?)
  ==> fix short names
- switch to binaryen 117

zarith improvement

branch minimize-runtime?

===========================

- build an archive from a cma file to cma.wasm.zip
  ===> multiple files (or single file?) + manifest
- compile cmo file to cmo.wasm
  ==> zip file as well?

- build an archive from cmo.wasm / cma.wasm.zip files

- link archives and cmo.wasm files to produce a js file + wasm.zip file
  (or explode into a directory? <<= might be better for source map files)

wasm (+ wasm.map files)

========================

do not warn about missing primitives in case of separate compilation?

runtime:
   include predefined exceptions / must be linked-in

["x", "y", "z", ...]
[0, 1, [], [2], [2,3], [3], [2,4], .., 0]
0 ==> await all the precedent ones before compiling this one + put into env
1 ==> await all the precedent ones before compiling this one + put into OCaml
list => await for the elements in this list before compiling

can we trim the dependency graph? (remove implied dependencies)

==============

- new style of exception handlers (?)

- call runtime based on function types
  --> i32  ==> box/unbox i32 (?)
      i64  ==> box/unbox i64
      f64  ==> box/unbox float
      externref ==> (call $unwrap/wrap) + extern.{in,ex}ternalize
      anyref ==> (call $unwrap/wrap)
      (ref i31)     ==> cast
      (ref $string)
      (ref $block)
      (ref $js)

===================

cmdline options: update description
.wasma for intermediate files?

---

1) link to directory
2) sourcemaps
3) support linking archives into archives
4) asm output

>>> Switch to binaryen 117 <<<


- iter over all modules, pushing a promise that waits for its
  dependencies then compile the code
- wait over all modules
