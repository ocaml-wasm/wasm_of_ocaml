
Get rid of Wa_ast.Seq?

=======

fix wa_minimize_locals (loops)
=> a variable set outside of a loop is live to the end of the loop if
   used in the loop

fix liveness (exceptions)

=======

Simple improvements
===================

- Rebuild call-graph
  ==> simplification of br_table/if

- wasm_of_ocaml specific binary: options + linking
  choose entry point
  linker
  ==> wasm_of_ocaml hello.bc smart_rollup_core.wasm runtime.wasm \
                 --entry kernel_run
      ==> hello.s (for debugging)
      ==> hello.wasm

=======

Optimization phases
===================

- local with a special type for env?
  (more generally, no longer use a generic type for locals)

- optimization pass:
  use tee to nest expressions (optimized away later on)
  mutator (call / array/struct.set) flush mutable
  other expressions can float until they are used
  flush at end of blocks

- how can we avoid some casts. see what ocaml does for floats
  shall we typecheck the program?

- local optimizations: multiple cast on the same value

=======

Remarks
=======

- issue: binaryen does not support block input parameters
  https://github.com/WebAssembly/binaryen/issues/5047

- performance of casts (v8):
 --experimental-wasm-assume-ref-cast-succeeds
 --experimental-wasm-skip-null-checks
 --experimental-wasm-skip-bounds-checks

- we have a problem with large number of variable during the
  initialization phase, which could be an issue for the GC
  ==> keep initial globals but remove entries?
  ==> run-length encoded stack maps?

==================

Possible improvements
=====================

- directly generate wasm binary?
  ==> the most stable way to use Binaryen will always be to pass it a WebAssembly binary https://github.com/WebAssembly/binaryen/issues/5591#issuecomment-1476497338
  ==> can include DWARF debug information + other custom sections
  ==> we may not need to support both a wast and an .s ouput

==============================================

DOCS

GHC: https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9204/diffs
     https://gitlab.haskell.org/ghc/ghc-wasm-meta

- C stubs to access the host functions
  https://reviews.llvm.org/D42520
  https://tezos.gitlab.io/alpha/smart_rollups.html#developing-wasm-kernels

- ABI
  https://github.com/WebAssembly/tool-conventions/

dart:
 https://github.com/dart-lang/sdk/blob/main/pkg/dart2wasm/lib/constants.dart

====================

BUILD PROCESS

dune exec -- js_of_ocaml --no-inline --pretty ~/tezos-noop-kernel/_build/default/src/hello.bc > /tmp/hello.s
clang-16  --no-standard-libraries --target=wasm32 /tmp/hello.s ../tezos-noop-kernel/_build/default/src/smart_rollup_core/smart_rollup_core.wasm ../tezos-noop-kernel/_build/default/src/runtime/runtime.wasm  -Wl,--no-entry -Wa,--no-type-check -o kernel.wasm

clang-16 -mexception-handling
wasm2wat --enable-exceptions  // --enable-all

dune exec -- js_of_ocaml --no-inline --pretty ~/tezos-noop-kernel/_build/default/src/hello.bc > /tmp/hello.wast
dune exec -- js_of_ocaml --no-inline --pretty ~/sources/tezos/_build/default/src/proto_alpha/bin_baker/main_baker_alpha.bc > /tmp/hello.wast

~/sources/binaryen/bin/wasm-opt --all-features -Oz /tmp/hello.wast -S -o -  | less
~/sources/wasm-gc-proposal/interpreter/wasm -d /tmp/hello.wast -o /tmp/hello.wat

===========================

GC proposal
===========

https://docs.google.com/document/d/1DklC3qVuOdLHSXB5UXghM_syCh-4cMinQ50ICiXnK3Q/edit#
https://github.com/WebAssembly/binaryen/blob/main/scripts/gen-s-parser.py
https://github.com/WebAssembly/gc/blob/main/interpreter/syntax/ast.ml

========

Curryfication improvements
==========================

- Each closure can hold several pointers (by copying the parent closure)
   caml_curry_n_1
- Curry function to perform a full apply when 3 arguments or less
   caml_curry_app_n_1
   caml_curry_app_n_2
   caml_curry_app_n_3
- Optimize caml_apply_n when overapplying or underapplying only a little
  Overapply:
    (f x1 ... xn') xn
    caml_apply2 (f x1 ... xn'') xn' xn
  Underapply:
    (fun x -> apply f x1 x2 ... xn x)
    (fun x y -> apply f x1 x2 ... xn x y)

    caml_apply_full_n_1
    caml_apply_full_n_2

==============================

Exception
=========

     res=f(...)
     if !res return res  (* Or jump to exception handler *)

     (No test necessary for tail calls)

     Store actual exception in a global variable

Trampoline
==========

     while(1) {
       res = f()
       if (res) return res
       if (exception pending) return res
       f = load_continuation()
     }

     if (depth < 40) f(x1, ..., xn)
     else { store (fun () -> f(x1, ..., xn)); return 0 }

     ===> create thunk functions

======================

Use one table by arity
===> function references / not supported by LLVM
===>
[wasm-gc] Optimize call_indirect type checks

Remove type check if declared signature exactly matches table
signature. Remove null check if the table is non-nullable.

=======================

We have unused globals (small constants / known closures)
===> eliminated by binaryen

===========================

Bindings:
   generate specialized JavaScript functions
      (for instance to create a literal object)
   optimize away unwrap(wrap(...))

===========================

Float unboxing: declare primitive type (or parse the runtime code to get the functions' parameter types?)

============================

Rethrow?

============================

Js_of_ocaml fixes:
==> Condition.wait should throw (never makes sense)
==> weak/ephemerons
==> Dom_html.Keyboard_code.of_event is weird

===================================

C API
=====
- https://github.com/hoodmane/libffi-emscripten
- use externref_t in clang-17
  typedef __externref_t externref_t;
  clang -c  --target=wasm32  -mreference-types

====================================================

Separate compilation (use wasm-merge for linking?)

Optimizations
- more efficient JavaScript bindings
- try to eliminate some casts / boxing
- revise bound-checking:
  => no separate checkbound (so that we can compute subexpressions only once)
  => CSE of casts / array.len
- more direct calls when we known which function is called
- objects (method calls)
- propagate more information from ocaml
  (extern statements / big array information / unsafe operation information / eqaul on int32 / ... / array length)
- use unboxed primitives for int64/int32/nativeint

============================

Doc: binding changes
- explicit coercion for floats
- cannot use ocaml physical equality to compare JavaScript values

====

wasm-opt -g only if --pretty

--traps-never-happen,-tnh ?

=====

NativeString ==> string.const

=============================

??? time_stamp_counter, bigstring_marshal_kernel,

====

export PATH=toto:/tmp/node-v21.0.0-v8-canary202307207f6d94de9e-linux-x64/bin:/home/jerome/V8/depot_tools:/home/jerome/.opam/4.14.0/bin:/home/jerome/sources/binaryen/bin:/home/jerome/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin
export PATH=toto:/tmp/node-v21.0.0-v8-canary20230906bca67b72ce-linux-x64/bin:/home/jerome/V8/depot_tools:/home/jerome/.opam/4.14.0/bin:/home/jerome/sources/binaryen/bin:/home/jerome/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin

opam reinstall -j 8 alcotest async_js base base_bigstring bigstringaf bin_prot core core_kernel core_unix cstruct cstruct-async cstruct-lwt cstruct-sexp cstruct-unix ppx_expect ppx_inline_test string_dict time_now zarith_stubs_js

=======

Release:
- many PRs (jsoo bindings, dune, brr, gen_js_api, ...)

=====

find . -name ".*"
find . -name "*jsoo" | xargs rm
find . -name "*.wat" | xargs rm
zip -r examples.zip `find . -name "*.wasm" | cut -d '/' -f 2 | sort`

=========================

zarith 1.13

==========================

Dune
====

- compile both to js and wasm
- set node options + variable for node

====

- update runtime code to new syntax
- improve dune support
- benchmarks: effects, js_of_ocaml benchmarks
- minify JS runtime
- separate compilation / toplevel
- use unboxed primitives for int64/int32/nativeint

- no longer use stringref (for now)
- eliom
- use br_if to handle bound errors

=====

string ==> JS
-------------
write string to buffer
if fits, just use the text decoder

otherwise, push a portion of the string
decode this portion
repeat until end of string
concat result

JS ==> string
-------------

var start= 0, len = s.length;
while (1) {
   var {read,written} = encodeInto(s.slice(start),buff);
   len -= read;
   if (!len) return written;
   extractString(written);
   start += read;
}
wasm: string segments are pushed, then concatenated together
with the last segment

alternative:
   measure length; allocate string; copy to buffer, then to string; return string
or:
   write to buffer; if fits, returns; otherwise, measure length, allocate string
   and start copying

  const mem16 = new Uint16Array(wasmExports.memory.buffer, address, length);
  const str = String.fromCharCode.apply(null, mem16);

  const mem16 = new Uint16Array(wasmExports.memory.buffer, dstAddr, srcLength);
  let arrayIndex = 0;
  let srcIndex = srcOffset;
  while (arrayIndex < srcLength) {
      mem16.set([src.charCodeAt(srcIndex)], arrayIndex);
      srcIndex++;
      arrayIndex++;
  }

===============

Benchmarks
==========
*   --experimental-wasm-skip-bounds-checks --experimental-wasm-skip-null-checks --experimental-wasm-assume-ref-cast-succeeds

==================

(type $closure_3
   (sub open $closure
      (struct (field $curry (ref $function_1)) (field $f (ref $function_3)))))

(type $curry_3_2
  (sub final $closure
    (struct
      (field (ref $function_1))
      (field $env (ref $curry_3_3))
      (field $arg2 (ref eq)))))

(type $curry_3_3
  (sub final $closure
    (struct (field (ref $function_1))
      (field $initial_closure (ref $closure_3))
      (field $arg1 (ref eq)))))

(func $curry (param $arg1 (ref eq)) (param $initial_closure (ref eq))
  (result (ref eq))
  (struct.new $curry_3_3
     (ref.func $curry_3_2)
     (ref.cast (ref $closure_3) (local.get $initial_closure))
     (local.get $arg1)))

(func $curry_3_2 (param $arg2 (ref eq)) (param $env (ref eq)) (result (ref eq))
  (struct.new $curry_3_2
     (ref.func $curry_app_3)
     (ref.cast (ref $curry_3_3) (local.get $env))
     (local.get $arg2)))

(func $curry_app_3 (param $arg3 (ref eq)) (param $env (ref eq)) (result (ref eq))
  (local (ref $curry_3_3))
  (local $initial_closure (ref $closure_3))
  (local.set 2
    (struct.get $curry_3_2 $env
      (ref.cast (ref $curry_3_2) (local.get $env))))
  (local.set $initial_closure
     (struct.get $curry_3_3 $initial_closure (local.get 2)))
  (return_call_ref $function_3_ch_
    (struct.get $curry_3_3 $arg1 (local.get 2))
    (struct.get $curry_3_2 $arg2
      (ref.cast (ref $curry_3_2) (local.get $env)))
    (local.get 0) (local.get $initial_closure))
    (struct.get $closure_3 $f (local.get 4))))

  (func $apply_3 (param (ref eq) (ref eq) (ref eq) (ref eq))
    (result (ref eq))
    (local (ref $closure_3) (ref eq) (ref eq) (ref eq) (ref eq) (ref eq)
      (ref eq))
    (drop
      (block (result (ref eq))
        (return_call_ref $function_3 (local.get 0) (local.get 1)
          (local.get 2)
          (local.tee 4
            (br_on_cast_fail 0 (ref eq) (ref $closure_3) (local.get 3)))
          (struct.get $closure_3 1 (local.get 4)))))
    (local.set 6
      (call_ref $function_1 (local.get 0) (local.tee 5 (local.get 3))
        (struct.get $closure 0
          (ref.cast (ref $closure) (local.get 5)))))
    (local.set 8
      (call_ref $function_1 (local.get 1) (local.tee 7 (local.get 6))
        (struct.get $closure 0
          (ref.cast (ref $closure) (local.get 7)))))
    (return_call_ref $function_1 (local.get 2)
      (local.tee 9 (local.get 8))
      (struct.get $closure 0 (ref.cast (ref $closure) (local.get 9)))))

=========================

Wasm GC getting finalized. Soon available by default on Chrome.

Js_of_ocaml successful project to make OCaml program run on a browser.

Goal: compile programs to Wasm with minimal changes

==============

Objectives
  => Js_of_ocaml
     => easy to use
     => easy to maintain
  => Maximal compatibility with Js_of_ocaml

Benchmarks:
- performance
  => ocamlc / microbenchmarks / camlboy
  => overhead of casts
- code size

Taking advantage of JavaScript
  => math
  => float conversions
  => (Weak)Map, Weak ==> ephemerons, marshalling
  => Bigint

Linking with JavaScript
  => wasm-dce + Js_of_ocaml linker

Interfacing with JavaScript
  => javascript objects are boxed
     => wrap/unwrap
     => physical equality no longer working
     => integers mapped to integers (cool!), but need a conversion between JS and OCaml floats
  => a few functions like caml_js_get / caml_js_meth_call
     (technique already used by Js_of_ocaml)
  => eventually, generate JS code (Js_of_ocaml generates inline JavaScript code)

Wish list
  => type imports + typed wasm-merge
     => do not duplicate some abstract types
     => check coherence
  => conversion between JS strings and array of bytes
     => go through memory
        ==> no standard way to reserve some memory
        ==> performance (several copies)
     => stringref
        ==> style in phase 1
     => JS String Builtins
  => typed arrays / buffers
     ==> I/Os
     ==> Camlboy writing to a framebuffer
  => faster exceptions (zero-cost exceptions are slow)

Effects
  => JS Promise API (quote Pierre)
  => (partial) CPS transformation



Wasm_of_ocaml: compiling OCaml bytecode to WebAssembly
Js_of_ocaml is a industrial-strength compiler that translates OCaml code into JavaScript. We will present how we are adapting it to produce WebAssembly. Beside the compilation process, we will cover a few key other points. First, how we interface with JavaScript, allowing to compile existing code with minimal changes. Second, we will show how we are relying on JavaScript to supplement some currently missing functionalities in WebAssembly. We are able to run substantial programs such as CAMLBOY, a Gameboy emulator, and the OCaml compiler itself. We will thus share some initial performance results.


how we interface with JavaScript, allowing to compile existing code with minimal changes. Second, we will show how we are relying on JavaScript to supplement some currently missing functionalities in WebAssembly

===========

Js.export???
