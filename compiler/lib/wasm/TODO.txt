
Get rid of Wa_ast.Seq?

=======

fix wa_minimize_locals (loops)
=> a variable set outside of a loop is live to the end of the loop if
   used in the loop

fix liveness (exceptions)

=======

Simple improvements
===================

- Rebuild call-graph
  ==> simplification of br_table/if

- wasm_of_ocaml specific binary: options + linking
  choose entry point
  linker
  ==> wasm_of_ocaml hello.bc smart_rollup_core.wasm runtime.wasm \
                 --entry kernel_run
      ==> hello.s (for debugging)
      ==> hello.wasm

=======

Optimization phases
===================

- local with a special type for env?
  (more generally, no longer use a generic type for locals)

- optimization pass:
  use tee to nest expressions (optimized away later on)
  mutator (call / array/struct.set) flush mutable
  other expressions can float until they are used
  flush at end of blocks

- how can we avoid some casts. see what ocaml does for floats
  shall we typecheck the program?

- local optimizations: multiple cast on the same value

=======

Remarks
=======

- issue: binaryen does not support block input parameters
  https://github.com/WebAssembly/binaryen/issues/5047

- performance of casts (v8):
 --experimental-wasm-assume-ref-cast-succeeds
 --experimental-wasm-skip-null-checks
 --experimental-wasm-skip-bounds-checks

- we have a problem with large number of variable during the
  initialization phase, which could be an issue for the GC
  ==> keep initial globals but remove entries?
  ==> run-length encoded stack maps?

==================

Possible improvements
=====================

- directly generate wasm binary?
  ==> the most stable way to use Binaryen will always be to pass it a WebAssembly binary https://github.com/WebAssembly/binaryen/issues/5591#issuecomment-1476497338
  ==> can include DWARF debug information + other custom sections
  ==> we may not need to support both a wast and an .s ouput

==============================================

DOCS

GHC: https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9204/diffs
     https://gitlab.haskell.org/ghc/ghc-wasm-meta

- C stubs to access the host functions
  https://reviews.llvm.org/D42520
  https://tezos.gitlab.io/alpha/smart_rollups.html#developing-wasm-kernels

- ABI
  https://github.com/WebAssembly/tool-conventions/

dart:
 https://github.com/dart-lang/sdk/blob/main/pkg/dart2wasm/lib/constants.dart

====================

BUILD PROCESS

dune exec -- js_of_ocaml --no-inline --pretty ~/tezos-noop-kernel/_build/default/src/hello.bc > /tmp/hello.s
clang-16  --no-standard-libraries --target=wasm32 /tmp/hello.s ../tezos-noop-kernel/_build/default/src/smart_rollup_core/smart_rollup_core.wasm ../tezos-noop-kernel/_build/default/src/runtime/runtime.wasm  -Wl,--no-entry -Wa,--no-type-check -o kernel.wasm

clang-16 -mexception-handling
wasm2wat --enable-exceptions  // --enable-all

dune exec -- js_of_ocaml --no-inline --pretty ~/tezos-noop-kernel/_build/default/src/hello.bc > /tmp/hello.wast
dune exec -- js_of_ocaml --no-inline --pretty ~/sources/tezos/_build/default/src/proto_alpha/bin_baker/main_baker_alpha.bc > /tmp/hello.wast

~/sources/binaryen/bin/wasm-opt --all-features -Oz /tmp/hello.wast -S -o -  | less
~/sources/wasm-gc-proposal/interpreter/wasm -d /tmp/hello.wast -o /tmp/hello.wat

===========================

GC proposal
===========

https://docs.google.com/document/d/1DklC3qVuOdLHSXB5UXghM_syCh-4cMinQ50ICiXnK3Q/edit#
https://github.com/WebAssembly/binaryen/blob/main/scripts/gen-s-parser.py
https://github.com/WebAssembly/gc/blob/main/interpreter/syntax/ast.ml

========

Curryfication improvements
==========================

- Each closure can hold several pointers (by copying the parent closure)
   caml_curry_n_1
- Curry function to perform a full apply when 3 arguments or less
   caml_curry_app_n_1
   caml_curry_app_n_2
   caml_curry_app_n_3
- Optimize caml_apply_n when overapplying or underapplying only a little
  Overapply:
    (f x1 ... xn') xn
    caml_apply2 (f x1 ... xn'') xn' xn
  Underapply:
    (fun x -> apply f x1 x2 ... xn x)
    (fun x y -> apply f x1 x2 ... xn x y)

    caml_apply_full_n_1
    caml_apply_full_n_2

==============================

Exception
=========

     res=f(...)
     if !res return res  (* Or jump to exception handler *)

     (No test necessary for tail calls)

     Store actual exception in a global variable

Trampoline
==========

     while(1) {
       res = f()
       if (res) return res
       if (exception pending) return res
       f = load_continuation()
     }

     if (depth < 40) f(x1, ..., xn)
     else { store (fun () -> f(x1, ..., xn)); return 0 }

     ===> create thunk functions

======================

Use one table by arity
===> function references / not supported by LLVM
===>
[wasm-gc] Optimize call_indirect type checks

Remove type check if declared signature exactly matches table
signature. Remove null check if the table is non-nullable.

=======================

Final types can be used for struct/array casts as well
==>
[wasm-gc] Final types

We add final types to wasm-gc.
- We introduce a `kWasmSubtypeFinalCode` as an alternative to
  `kWasmSubtypeCode`.
- Behind a flag, we interpret types behind this code as final, as well
  as types outside a subtype definition by default.
- For final types, type checks for call_indirect and ref.test etc. are
  reduced to simple type identity checks.

====================

We have unused globals (small constants / known closures)
===> eliminated by binaryen

===========================

Bindings:
   generate specialized JavaScript functions
      (for instance to create a literal object)
   optimize away unwrap(wrap(...))

===========================

Float unboxing: declare primitive type (or parse the runtime code to get the functions' parameter types?)

============================

Use WASI for system functions

NativeString ==> stringref const

============================

Rethrow?

============================

Js_of_ocaml fixes:
==> bound check optimization for float arrays
==> strict equality
==> Condition.wait should throw (never makes sense)

===============================

Performance improvements:
- Refine exact calls: when there is a single function called, then we
  can call it directly.
- float arrays
- use unboxed primitives for int64/int32/nativeint

===================================

C API
=====
- https://github.com/hoodmane/libffi-emscripten
- use externref_t in clang-17
  typedef __externref_t externref_t;
  clang -c  --target=wasm32  -mreference-types

====================================================

Compilation process
===================

wasm_of_ocaml foo.bc ==> foo.js / foo.wasm
   - compile to a temp file (.wat file with -S option)
minify js runtime

===

TODO:

Implement runtime code
- file system access
- marshalling
- weak pointer api
  ==> Use Javascript weak pointer implementation
...

Separate compilation (use wasm-merge for linking?)

Optimizations
- more efficient JavaScript bindings
- unboxed float arrays
- try to eliminate some casts / boxing
- more direct calls when we known which function is called
- objects (method calls)
- propagate more information from ocaml
  (extern statements / big array information / unsafe operation information)

=================

Remaining runtime code:
- printing errors (needs basic implementation of stderr on browsers)
- weak / ephemeron
- marshaling
- filesystem / IOs
- dynlink / toplevel / separate compilation
- jslib_js_of_ocaml

Less important:
- graphics
- nat

Files:
  dynlink
  fs
  graphics
  io
  jslib_js_of_ocaml
  marshal
  md5 (not channel)
  nat
  runtime_events
  stdlib
  sys
  toplevel
  unix (gettimeofday / time / gmtime)
  weak

- node bindings (I/Os)
- virtual filesystem
- toplevel

=========================

TODO

- dune support
  ==> link (wasm_runtime) wat/wast/wasm files
  ==> wasm_files
  ==> node options ===> (node_flags ...)

- we should link-in javascript files that are not divided into fragments

- documentation
  ==> what tools (node/chrome/binaryen/dune) are needed/supported
  ==> how do we run wasm_of_ocaml
      output: foo.js / foo.wasm / foo.wat
      wasm-opt -all -S -o - foo.wasm

=================================

Linker:
annotate provides to indicate that they should be available in Wasm

============================

Doc: binding changes
- explicit coercion for floats
- cannot use ocaml physical equality to compare JavaScript values

====

wasm-opt -g only if --pretty

--traps-never-happen,-tnh ?

=====

NativeString ==> string.const

=====================================

wasm_of_ocaml
- easy to use (do not need to reinstall many libraries specifically for wasm)

flambda-to-wasmgc
- behaves as a cross-compiler
- more optimizations: flambda (2) optimizations, unboxing, ...

We can cooperate:
- common runtime
- common interface with JavaScript / C

=============================

* incr_mod
* base
* core
  bin_prot
  base_bigstring

==============================

marshaling: use JavaScript maps

========================================

Ty:
Making libraries that depend on C stubs work in js_of_ocaml is already a lot of work.  If we now need to write wasm bindings, it'll take years before enough of janestreet's codebase is converted to be useful

Ron:
- But the "drop-in-replacement" argument is strongest if users can continue to use their existing js-of-ocaml bindings. Ty asked about that elsewhere, but I don't see a response. I think this is a big deal for us.

This seems like an important point. @jerome@tarides.com , do you have more thoughts about the migration story for folk like us who are heavy users of jsoo, and who don't use Brr at all, and only make minor use of Gen_js_api?

We might be able to make this easier to think about by providing examples of low-level code that we'd like to make sure works seamlessly.

================

Flamba2

Pierre Chambard is probably better positioned than we are to work on a Flamba2 backend.
JavaScript linking and minimization ?
What about deadcode elimination ? Is it something that you care about ?


Not make any decision that would make it harder to start from flamba2.


==> Pierre Chambard is probably the right person to work on this
==> generating Wasm code from flambda2 not a huge effort
==> do we need to keep anything from js_of_ocaml? many optimizations
already dones by flambda2. dead code elimination?
==> with Pierre, we agree on the representation of OCaml values,
    so we can share a common runtime
==> not sure about how to represent unboxed types in Wasm
    gc friendly => array of values
    no-gc
    => struct (but we need the whole struct information,
               or at least a prefix to access a value)

With wasm_of_ocaml, we implement a large part of what is needed to run OCaml on Webassembly.
Flambda2 backend
==> same runtime
==> same APIs
==> get some idea from the js_of_ocaml implementation
    (like how to recover a structered control flow)



I'm wondering what are the gains in adapting js_of_ocaml to use the Flambda2 IR compared to writing a Wasm backend for the OCaml compiler.

In any case, I think there is a lot we can reuse from this work. I discussed with Pierre Chambart, and we agree on the representation of OCaml values. So I believe we can share a common runtime.

We will also gain some insights into how to compile smoothly OCaml programs to WebAssembly. In particular, we will have the very same issues regarding supporting existing js_of_ocaml bindings with an flambda2 backend.

=======================================

 50399 ./zarith_stubs_js.v0.15.0/biginteger.js
 28943 ./zarith_stubs_js.v0.15.0/runtime.js
  5806 ./base.v0.16.0/src/runtime.js
  3306 ./core.v0.16.0/core/src/runtime.js
  2976 ./bin_prot.v0.16.0/src/runtime.js
  2958 ./base_bigstring.v0.16.0/src/runtime.js
  2026 ./string_dict.v0.15.0/src/string_dict.js
  1518 ./incr_dom.v0.15.1/javascript_profiling/runtime.js
  1253 ./ppx_expect.v0.16.0/collector/runtime.js
   889 ./core_kernel.v0.15.0/version_util/src/version_util.js
   703 ./base.v0.16.0/hash_types/src/runtime.js
   456 ./timezone.v0.15.0/src/runtime.js
   435 ./time_now.v0.16.0/src/runtime.js
   120 ./core.v0.16.0/heap_block/runtime.js
    77 ./ppx_inline_test.v0.16.0/runner/lib/runtime.js

* core/src/runtime.js
* core/heap_block/runtime.js
* core_kernel/version_util/src/version_util.js
* zarith_stubs_js/src/biginteger.js
* zarith_stubs_js/src/runtime.js
* string_dict/src/string_dict.js
* time_now/src/runtime.js
* incr_dom/javascript_profiling/src/runtime.js
* ppx_inline_test/runner/lib/runtime.js
* ppx_expect/collector/runtime.js
* bin_prot/src/runtime.js
* base/hash_types/src/runtime.js
* base_bigstring/src/runtime.js
* base/src/runtime.js

cstruct/src/cstruct.js
bigstringaf/lib/runtime.js
alcotest/src/alcotest/runtime.js

??? time_stamp_counter, bigstring_marshal_kernel, async_js_test

====================

Explain set-up
- binaryen (https://github.com/vouillon/binaryen/tree/wasm-merge)
- chrome dev (+ chrome://flags/)
- node nightly (+flags)

How to compile
- wasm_of_ocaml --pretty  --opt 3 ~/CAMLBOY/_build/default/bin/web/bench.bc-for-jsoo

Fix opam installation (dependency on Js_of_ocaml)

TODO:
- linking WebAssembly files
- dune support
